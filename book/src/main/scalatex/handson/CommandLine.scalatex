@import book.BookData._

@p
  We've by this point done a bunch of work in the browser: we've made a small game that runs in the web browser on the HTML5 canvas, and we've made a number of small web-apps that interact with HTML and 3rd party web-services. However, there's a whole other side to the Scala.js ecosystem: the command line interface, or CLI.

@p
  Even though the goal of Scala.js is to get your code running in peoples' browsers, it still is useful to be familiar with the things that you can do in the command-line. It is much easier to write-code-print-results in the command line without having to set up a HTML page and opening a browser to test it, and this extends to things like unit test suites, which are almost exclusively run in the command-line using @code{sbt ~test} to keep re-running them when the code changes.

@p
  The Scala.js command line is where you go to do things to your Scala.js code. Although Scala.js comes with @lnk("standalone executables", "http://www.scala-js.org/downloads.html") that can be used from any shell (sh, bash, zsh, etc.) the primary supported way of setting up, compiling and testing your Scala.js applications is through @lnk.misc.sbt: Scala's primary build tool.

@p
  You've already used fragments of the Scala.js CLI in earlier chapters of this book: @code{~fastOptJS} is what you used for development, @code{fullOptJS} for publishing. Apart from these, Scala.js allows you to execute code via @lnk.misc.Nodejs/@lnk.misc.jsdom/@lnk.misc.Selenium from the command-line, as well as running test-suites under the same conditions. This chapter will go deeper into the various things you can do with the Scala.js command line:

@ul
  @li
    @code{compile}: converting code from Scala source into not-yet-executable Scala.js IR
  @li
    @code{package}: bundling up our Scala.js IR into a @code{.jar} file, for publishing or distribution as a library
  @li
    @code{fastOptJS}: aggregating our Scala.js IR and converting it to a @code{.js} executable.
  @li
    @code{fullOptJS}: aggregating our Scala.js IR and converting it to a smaller, faster @code{.js} executable.
  @li
    @code{run}: run your compiled Scala.js code as JavaScript in Node.js, jsdom or Selenium
  @li
    @code{test}: run your compiled Scala.js code as a test suite in Node.js, jsdom or Selenium

@p
  Now, let's open up your sbt console in your Scala.js app

@hl.sh
  $ sbt
  >

@p
  And let's get started!

@sect{Commands}
  @p
    The most fundamental thing you can do in the Scala.js CLI is to compile your code. Let's go through the various mechanisms of "compiling" things:

  @sect{The compile Command}
    @hl.sh
      > compile

    @p
      Just as you can @code{compile} Scala-JVM projects, you can also @code{compile} Scala.js projects. Like compiling Scala-JVM projects, this leaves a bunch of @code{.class} files in your @code{target} directory. Unlike Scala-JVM projects, this also leaves a bunch of @code{.sjsir} files, which correspond to your Scala.js output files:

    @hl.sh
      classes
      └── example
          ├── Point$.class
          ├── Point$.sjsir
          ├── Point.class
          ├── Point.sjsir
          ├── ScalaJSExample$$anonfun$main$3.class
          ├── ScalaJSExample$.class
          ├── ScalaJSExample$.sjsir
          ├── ScalaJSExample.class
          └── ScalaJSExample.sjsir

    @p
      However, unlike on Scala-JVM, you cannot directly run the @code{.sjsir} files spat out by the Scala.js compiler. These files are an Intermediate Representation, which needs to go through the next step in the compilation pipeline before being turned into JavaScript.

  @sect{The package Command}
    @hl.sh
      > package
    @p
      Also like on Scala-JVM, Scala.js also supports the @code{package} command. This command generates a @code{.jar} like it does in Scala-JVM, except this version appends this weird @code{_sjs1} suffix.

    @hl.sh
      target/scala-2.13/
      └── example_sjs1_2.13-0.1-SNAPSHOT.jar

    @p
      The purpose of this suffix is to link the compiled @code{.jar} file to the version of Scala.js used to compile it. This allows you to make sure that you don't accidentally depend on a version of a jar that is incompatible with your current version, such as one compiled with Scala.js 0.6.x.

    @p
      Again, unlike Scala-JVM, these @code{.jar} files are not directly executable: the @code{.sjsir} files need further processing to turn into runnable JavaScript. Instead, their sole purpose is to hold bundles of @code{.sjsir} files to be published and depended upon: they can be @code{publishLocal}ed to be used by other projects on your computer, or @code{publishSigned}ed to @lnk("Maven Central", "https://search.maven.org/"), just like any Scala-JVM project.

  @sect{The fastOptJS Command}
    @hl.sh
      > fastOptJS
    @p
      @code{fastOptJS} is a command we've used in earlier chapters. It basically runs the @sect.ref{Fast Optimization} stage of the compilation pipeline. This results in a moderately-sized executable, which you can then load in the browser with a @hl.xml{<script>} tag and run.

    @p
      This is the first phase which actually results in an executable blob of JavaScript. I won't go into much detail about this command: you've used it before, and more details about the particular kind of optimization and how it fits into the large process is available in the chapter on The Compilation Pipeline. Nonetheless, it's fast, produces not-too-huge output code, and is what you typically use for iterative development in the browser.

  @sect{The fullOptJS Command}
    @hl.sh
      > fullOptJS
    @p
      @code{fullOptJS} is another command that we've seen before: it performs an aggressive, somewhat slower @sect.ref{Full Optimization} pass on the generated JavaScript. This results in a much smaller executable JavaScript blob, which you can also load via a @hl.xml{<script>} tag and run.
    @p
      Again, I won't go into much details, as exactly what this optimization does is described in the chapter on the Compilation Pipeline. This command is somewhat too-slow to be running during iterative development, and is instead typically used just before deployment to minimize the size of the file your users have to download.

  @sect{The run Command}
    @hl.sh
      > run
    @p
      Here's something you haven't seen before: the @code{run} command gives you the ability to run a Scala.js program from the command line. This prints its output to standard output (i.e. the terminal). Like Scala-JVM, you need a @hl.scala{def main(args: Array[String]): Unit} method to run, or kick off, your program. For example:

    @hl.scala
      // src/main/scala/RunMe.scala
      object RunMe {
        def main(args: Array[String]): Unit = {
          println("Hello World!")
          println("In Scala.js, (1.0).toString is ${(1.0).toString}!")
        }
      }

    @p
      In addition, and unlike Scala-JVM, you need the following setting in the `build.sbt` of the project:

    @hl.scala
      // in build.sbt
      scalaJSUseMainModuleInitializer := true

    @p
      Running the sbt command @code{run} with the above Scala.js code will print out

    @hl.sh
      Hello World!
      In Scala.js, (1.0).toString is 1!

    @p
      This exhibits the weirdness of @hl.scala{Double.toString} in Scala.js, which is one of the few ways in which @sect.ref("Deviations from Scala-JVM", "Scala.js deviates from Scala-JVM"). This also shows us we're really running on Scala.js: on Scala-JVM, @hl.scala{(1.0).toString} returns @hl.scala{"1.0"} rather than @hl.scala{"1"}!

    @p
      One thing you may be wondering is: when you run a Scala.js program in the terminal, how does it execute the output JavaScript? What about the DOM? and Ajax calls? Can it access the filesystem? The answer to all these questions is "it depends": it turns out there are multiple ways you can run Scala.js from the command-line, dictated by the @i{stage} and the @i{environment}.

    @p
      By default, runs are done in the @code{FastOptStage} (with fast optimizations) and in the @lnk.misc.Nodejs environment. Other JavaScript environments, such as @lnk.misc.jsdom or @lnk.misc.Selenium, can be selected with the @code{jsEnv} setting. For example, to enable jsdom and get support for a DOM, follow the instructions of @lnk.misc.jsdomJSEnv.

    @p
      The next two sections elaborate on the differences between these ways of running your code. Check out the later sections on @sect.ref{Headless Runtimes} and @sect.ref{Stages} to learn more about the other settings and why you would want to use them.

  @sect{The test Command}
    @hl.sh
      > test

    @p
      The @code{sbt test} command behaves very similarly to @code{sbt run}. It also runs on Node.js or any other JavaScript environment, depending on your settings.
    @p
      The difference is that instead of simply running your @code{main} method, @code{sbt test} runs whatever test suite you have set-up, which will look through your @code{tests/} folder to find suites of tests it has to run, and aggregate the results formatted nicely for you to see. The exact operation of this depends on which testing library you're using.
    @p
      We won't spend much time talking about @code{sbt test} here. Not because it's not important: it most certainly is! Rather, we will be spending a good amount of time setting up tests in @sect.ref("Cross Publishing Libraries", "the next chapter"), so feel free to jump ahead if you want to see an example usage of @code{sbt test}.

@sect{Headless Runtimes}
  @ul
    @li
      @lnk.misc.Nodejs is the default way of running Scala.js applications on the command line, since it is the de facto software to run JavaScript code outside of Web browsers. Based on Google's V8 JavaScript engine, its performance matches that of modern browsers. Node.js does not have DOM or browser-related functionality.
    @li
      @lnk.misc.jsdom is a Node.js library that can execute code in a sandboxed environment featuring an implementation of the DOM. This is very useful to run code that requires DOM manipulations without spawning a full browser. You can configure Scala.js to run and test in that sandboxed environment with @lnk.misc.jsdomJSEnv.
    @li
      @lnk.misc.Selenium is a programmatic driver for real, headless browsers. Unlike jsdom, Selenium provides you with a full DOM in a real browser. You can use it in Scala.js with @lnk.misc.SeleniumJSEnv.
    @li
      Obsolete: @lnk.misc.PhantomJS is a headless browser based on WebKit, the JavaScript engine of Safari. PhantomJS has been discontinued by its maintainers in 2018. For backward compatibility reasons, a legacy environment @lnk.misc.PhantomJSJSEnv is still provided to use it in Scala.js, but its use is not recommended anymore.
  @p
    Node.js, jsdom and Selenium are your three main options to run your Scala.js code via the command-line. Third-party projects can provide additional JavaScript environments to use with Scala.js, if the above three do not cover your use cases.

@sect{Stages}
  @p
    By default, runs and tests are done in the @code{FastOptStage}, which means that they use the JavaScript files produced by @code{fastOptJS} (with fast optimizations). This is usually what you want in your development cycle, since fast optimizations hit a sweet spot between the time taken to generate the JavaScript file and its performance, in addition to providing better debugging tools (full names, checks for @sect.ref("Undefined behaviors", "undefined behaviors"), etc.).

  @p
    You can enable full optimizations, @code{FullOptStage}, with the following sbt command:

  @hl.sh
    > set Global/scalaJSStage := FullOptStage
    > run

  @p
    Changing the stage to @code{FullOptStage} will cause @code{run} and @code{test} commands to use the JavaScript files produced by @code{fullOptJS}, featuring full optimizations. This is slower, but is still useful to verify that the behavior does not change (it shouldn't!) under the aggressive full optimization. This is typically used in continuous integration builds, but rarely manually.

@hr

@p
  Hopefully by this point you more-or-less know your way around the Scala.js command-line tools. As mentioned earlier, command line tools make it much easier to run a bunch of Scala.js code, e.g. unit tests, without having to muck around with HTML pages or refreshing the browser. That will come in handy soon, as we're next going to learn to publish a standalone, distributable Scala.js module. And what's a module without tests...
